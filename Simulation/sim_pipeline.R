##############################################
##         Evolution Project 2021           ##
## Trait dependence shifts simulation study ##
##        Bruno do Rosario Petrucci         ##
##############################################

### 
# packages required

# paleobuddy
load_all()

# APE (for saving trees)
library(ape)

# readr (for write_tsv)
library(readr)

###
# simulation pipeline settings:
# Number of traits: 2
# Trait evolution 1: Brownian Motion
  # X0: 1.384
  # sigma2: posterior mean +- posterior sd (calibration)
# Trait evolution 2: BiSSE
  # states: c(0, 1)
  # X0: 0
  # Transition rates : q01+q10 = 0.0365 (sum of posterior means)
  # q10 > q01, q10 = q01, q10 < q01 (for each, 25% lower/higher)
# duration of ME: 1, 5 and 10 my
# duration of RE: same
# rho: 0.79 (MLE from calibration data)
# mu_bg: 0.428 (posterior mean from calibration Rev)
# mu_me from expected pruning 0.5, 0.75, 0.9
# lambda_bg: 0.642 (posterior mean from calibration Rev)
# lambda_re from expected recovery 1, 1.25 and 1.5 * species during ME
  # all of these expected (exp value of trait -> exp value
  # of function of trait -> exp value of rate)
# nExp: 2 * minimum
# nFinal: c(0.75 * 94, Inf), minimum equal to calibration tree size

###
# set up the baseline simulation settings

# expected number of total (living + extinct) species
nExp <- 200

# minimum and maximum number of species
nMin <- nExp / 4
nMax <- nExp * 3

# interval of accepted species 
nFinal <- c(nMin, nMax)

# calibration values
lambda_bg <- 0.2

mu_bg <- 0.12

rho <- 0.79

# take bins represented in fossil canids as geological bins
calibDir <- "C:/Users/bruno/Documents/RESEARCH/PhD/EvolProject2021/Calibration/"
fossilsCalibration <- read.delim(paste0(calibDir, "data/fossils.tsv"))
bins <- sort(unique(c(fossilsCalibration$min, fossilsCalibration$max)), 
             decreasing = TRUE)

# number of expected species at the beginning of the ME
nME <- 35

# mass extinction event starting time
# calculate it so we expect 1/2 of species before it happens
meStart <- log(nME) / (lambda_bg - mu_bg)

# mass extinction duration
meDur <- 5

# variations we want to test
meDurChange <- c(10, 1)

# recovery starting time
reStart <- meStart + meDur

# recovery duration
reDur <- 5

# variations we want to test
reDurChange <- c(10, 1)

# ME intensity
meInt <- 0.75

# variations we want to test
meIntChange <- c(0.9, 0.5)

# ME rate
# such that we expect meInt * number of species before ME to go extinct
mu_me <- (log(meInt) + lambda_bg * (meDur + meStart) - mu_bg * meStart) / meDur

# recovery percentage (compared to diversity lost during ME)
reInt <- 1.25

# variations we want to test
reIntChange <- c(1.5, 1)

# speciation recovery rate
# such that we expect reInt * number of expected ME species to go extinct
lambda_re <- (log(reInt) + mu_bg * reDur +  mu_me * meDur
              - lambda_bg * meDur) / reDur

# rates

# null model: rates are not trait dependent
lambda_null <- stepfun(c(reStart, reStart + reDur),
                       c(lambda_bg, lambda_re, lambda_bg))

mu_null <- stepfun(c(meStart, meStart + meDur),
                  c(mu_bg, mu_me, mu_bg))

# check how many species are expected by meStart + meDur + reDur
# number of living species at time t
expNt <- Vectorize(function(t) {
  exp(integrate(function(x) lambda_null(x) - mu_null(x), 0, t)$value)
})

# total number of species generated by time t
expTotalNt <- function(t) {
  integrate(function(x) lambda_null(x) * expNt(x), 0, t, 
            stop.on.error = FALSE)$value + 1
}

# find tMax such that the expected number of species is nExp
tMax <- uniroot(function(t) expTotalNt(t) - nExp, 
                c(meStart + meDur + reDur, meStart + meDur + reDur + 10))$root

# tested model: rates are trait dependent

# speciation: increases with discrete trait during
# BG, modulated by continuous trait during RE

# extinction: modulated by continuous trait during
# BG, increases with discrete trait during ME

# continuous trait mean
bmX0 <- 1.384

# posterior mean for sigma2
bmSigma2 <- 0.0217

# posterior stdev for sigma2
bmSigma2Stdev <- 0.0034

# variations we want to test
bmSigma2Change <- bmSigma2 + c(1, -1) * 2 * bmSigma2Stdev

# set bounds for body size - a bit under and 
# over min and max of calibration data
bmBounds <- c(0.5, 4)

# discrete trait starting state
stX0 <- 0

# function to find expected value of
# discrete trait given q01 and q10 in (0, tMax)
expected.trait <- function(q01, q10) {
  q <- q01 + q10
  q01 / q * 1 / tMax *
    ((exp(-q*tMax) - 1) / q + tMax)
}

# sum of posterior means of Q01 and Q10
stQSum <- 0.0365

# make them equal at baseline
stQ01 <- stQSum / 2
stQ10 <- stQSum - stQ01

# variations we want to test (q01 25% higher and 25% lower)
stQ01Change <- stQ01 + c(1, -1) * 0.25 * stQ01

# transition matrix
stQ <- matrix(c(0, stQ01, stQ10, 0), 2, 2)

# get expected value of trait
EX <- expected.trait(stQ01, stQ10)

# speciation multiplier for state 1
lambdaModDisc <- 1

# assume lambda_bg = y + y*modifier*X, where X is trait
lambda_bg_0 <- lambda_bg / (1 + lambdaModDisc * EX)

# lambda_re decreases by 5% with one
# unit of body size away from optimum
lambdaModCont <- 0.05 

# define lambda such that the expected value during 
# BG is lambda_bg, and during RE is lambda_re
lambda <- function(t, traits) {
  reStart <- meStart + meDur
  reEnd <- reStart + reDur
  ifelse((t < reStart) || (t > reEnd),                    
         # BG
         lambda_bg_0 + lambda_bg_0 * lambdaModDisc * traits[2],
         # RE
         lambda_re + lambdaModCont * lambda_re * 
           (abs(bmX0 - traits[1])))# - sqrt(2 * bmSigma2 * t / pi)))
}
# in other words, E[lambda] = lambda_null
# the sqrt(...) is required due to the expectation of abs(X), X being normal

# extinction multiplier for state 1
muModDisc <- 0.5

# assume mu_me = y + y*modifier*X, where X is trait
# so extinction for state 1 is 1.5 that of state 0
mu_me_0 <- mu_me / (1 + muModDisc * EX)

# mu_bg increases by 5% with one
# unit of body size away from optimum
muModCont <- 0.05

# define mu such that the expected value during
# BG is mu_bg, and during ME is mu_me
mu <- function(t, traits) {
  ifelse((t < meStart) || (t > meStart + meDur),
         # BG
         mu_bg + muModCont * mu_bg  * 
           (traits[1] - bmX0),# - sqrt(2 * bmSigma2 * t / pi)),
         # ME
         mu_me_0 + mu_me_0 * muModDisc * traits[2])
}
# in other words, E[mu] = mu_null

# number of reps to run each combination of parameters
nReps <- 50

###
# create directories for saving data

# make a smarter dir.create function
smart.dir.create <- function(dir) {
  if (!dir.exists(dir)) dir.create(dir)
}

# get the base directory where everything should be
baseDir <- "C:/Users/bruno/Documents/RESEARCH/PhD/EvolProject2021/Simulation/"

# create a directory to hold all simulations
simDir <- paste0(baseDir, "replicates/")
smart.dir.create(simDir)

###
# consider parameter changes and run simulations

# collect baseline parameters in a data
# frame that will later become the key

key <- data.frame(ref = "base",
                  meDur = meDur,
                  reDur = reDur,
                  meInt = meInt, 
                  reInt = reInt,
                  bmSigma2 = bmSigma2,
                  stQ01 = stQ01,
                  lambdaModDisc = lambdaModDisc,
                  lambdaModCont = lambdaModCont,
                  muModDisc = muModDisc,
                  muModCont = muModCont)

# make a vector to hold the baseline parameters
base <- key[1, ]

# reference vector for each parameter change
refs <- c("longME", "shortME", "longRE", "shortRE", "hIntME", "lIntME", 
          "hIntRE", "lIntME", "highVar", "lowVar", "high01", "high10")

# the corresponding column numbers to change in the base
change <- c(2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7)

# the new values
new <- c(meDurChange, reDurChange, meIntChange, 
         reIntChange, bmSigma2Change, stQ01Change)

# copy the baseline a bunch of times to fill the key
key <- rbind(key, key[rep(1, length(change)), ])
rownames(key) <- 1:nrow(key)

# populate it with the values in aux
for (i in 2:nrow(key)) {
  key$ref[i] <- refs[i - 1]
  key[i, change[i - 1]] <- new[i - 1]
}

# save key
write_tsv(key, file = paste0(simDir, "key.tsv"))

###
# auxiliary functions

# make a make.phylo output usable by FBD in RevBayes
# credit: Joshua Justison
collapseFossils <- function(tree) {
  # number of tips in the original tree
  nTips <- length(tree$tip.label)
  
  # indices to delete - edges with length 0
  delInd <- tree$edge.length == 0
  
  # tips to delete
  deletedTips<- tree$edge[delInd, 2]
  
  # get the labels of the deleted tips
  internalLabels <- tree$tip.label[deletedTips]
  
  # node numbers for the tips we are deleting
  nodeNumbers <- tree$edge[delInd, 1]
  
  # drop tips, but keep them as nodes (collapse.singles = FALSE)
  tree <- drop.tip(tree, deletedTips, collapse.singles = FALSE)
  
  # reset node labels
  tree$node.label <- rep("",rep(tree$Nnode))
  
  # add previous deleted tips' labels to the new nodes
  tree$node.label[nodeNumbers - nTips] <- internalLabels
  
  return(tree)
}

###
# write simulation functions

# minimum number of sampled species
# 1/2 of minimum number of species
minSamp <- nMin / 2

# minimum mean number of fossil occurrences per sampled species
minFossilsSp <- 1

# and maximum 
maxFossilsSp <- 20
# these will be used to multiply by #sampled and get an average expected

# create simulation function for one rep
simulate_rep <- function(tMax, lambda, mu, nFinal, rho, bins,
                             bmSigma2, bmX0, stQ, stX0, null = FALSE) {
  # minimum variance for continuous trait values at the extant tips
  # half of expected
  minVar <- 0.5 * bmSigma2 * tMax
  
  # set up test so while loop runs
  bounds <- FALSE
  
  # create pars list
  pars <- list("BM" = list("X0" = bmX0, "sigma2" = bmSigma2, 
                           "bounds" = list(bmBounds)),
               "ST" = list("states" = list(c(0, 1)), 
                           "X0" = stX0, "Q" = list(stQ)))
  
  # counter to make sure we don't have to repeat too many times
  counter <- 1
  
  # while out of bounds
  while (!bounds) {
    if (null) {
      # run simulation - want at least one living species at the end
      sim <- bd.sim(1, lambda_null, mu_null, tMax, nFinal = nFinal, nExtant = c(5, Inf))
    } else {
      # run simulation - want at least one living species at the end
      sim <- bd.sim.traits(1, lambda, mu, tMax, nTraits = 2,
                           traitModel = c("BM", "ST"), pars = pars,
                           nFinal = nFinal, nExtant = c(2, Inf))
      
      # get trait function lists
      traitCont <- lapply(1:length(sim$TRAITS), function(x) 
        sim$TRAITS[[x]]$trait1)
      traitDisc <- lapply(1:length(sim$TRAITS), function(x) 
        sim$TRAITS[[x]]$trait2)
      
      names(traitCont) <- names(traitDisc) <- paste0("t", 1:length(sim$SIM$TS))
      
      # and just sim
      sim <- sim$SIM
    }
    
    # get fossil samples
    sample <- data.frame()
    while (nrow(sample) == 0) {
      sample <- suppressMessages(sample.clade(sim, rho, tMax, 
                                              bins = bins, returnAll = TRUE))
    }
    
    # number of sampled species
    nSampled <- length(unique(sample$Species))
    
    # get actual min and max fossils given number of sampled species
    minFossils <- minFossilsSp * nSampled
    maxFossils <- maxFossilsSp * nSampled
    
    # make a molecular tree
    tree <- drop.fossil(make.phylo(sim))
    
    # and an SA tree
    # remembering to drop extinct taxa and keep only the fossils
    saTree <- drop.tip(make.phylo(sim, sample), 
                       tip = paste0("t", which(!sim$EXTANT)))
    
    # get a list of taxa for tree and SAtree
    saTreeTaxa <- as.numeric(unlist(lapply(saTree$tip.label, 
                                           function(x) sub("t", "", x))))
    
    # get an fbd tree with SAs collapsed as nodes with degree 2
    fbdTree <- collapseFossils(saTree)
    
    # check if null
    bounds <- (nSampled > minSamp) &&
      (nrow(sample) < maxFossils) &&
      (nrow(sample) > minFossils)
    
    if (!null) {
      # times to sample traits
      saTreeTraitSampT <- 
        lapply(saTreeTaxa,
               function(x)
                 ifelse(x == floor(x), tMax, tMax - 
                          sample[sample$Species == 
                                   paste0("t", floor(x)), 
                                 "SampT"][round(10*(x - floor(x)))]))
      
      # the present for extant species, sampling time for fossils
      names(saTreeTraitSampT) <- paste0("t", saTreeTaxa)
      
      # and make the trait lists
      saTreeTraitsCont <-
        as.numeric(unlist(lapply(saTreeTaxa,
                                 function(x)
                                   traitCont[[paste0("t", floor(x))]](
                                     saTreeTraitSampT[[paste0("t", x)]]
                                   ))))
      saTreeTraitsDisc <-
        as.numeric(unlist(lapply(saTreeTaxa,
                                 function(x)
                                   traitDisc[[paste0("t", floor(x))]](
                                     saTreeTraitSampT[[paste0("t", x)]]
                                   ))))
      
      # check variance for the continuous traits
      varCont <- var(saTreeTraitsCont)
      
      # and sum of discrete traits - we want there to be at least 4 of each
      sumDisc <- sum(saTreeTraitsDisc)
      
      # checks if not null
      bounds <- (nSampled > minSamp) &&
        (nrow(sample) < maxFossils) &&
        (nrow(sample) > minFossils) &&
        (varCont > minVar) &&
        (sumDisc > 5) &&
        (sumDisc < (length(saTreeTaxa) - 5))
    }
    
    # if counter is higher than 10, maybe rethink the parameters
    if (counter > 10) stop("Hard to find replicate within bounds")
  }
  
  # make a list to return
  if (null) {
    res <- list(SIM = sim, SAMP = sample, 
                TREE = tree, SATREE = saTree, FBDTREE = fbdTree)
  } else {
    res <- list(SIM = sim, SAMP = sample, 
                TREE = tree, SATREE = saTree, FBDTREE = fbdTree,
                TRAITFUNCC = traitCont, TRAITFUNCD = traitDisc,
                TRAITSC = saTreeTraitsCont, TRAITSD = saTreeTraitsDisc)
  }
  
  return(res)
}

# create function to run simulations 
# for a list of parameters
simulate <- function(nReps, comb, key) {
  ## recover parameters from key
  pars <- key[comb, ]
  
  meDur <- pars[["meDur"]]
  
  reStart <- meStart + meDur
  
  reDur <- pars[["reDur"]]
  
  meInt <- pars[["meInt"]]
  
  mu_me <- (log(meInt) + lambda_bg * (meDur + meStart) - mu_bg * meStart) / meDur
  
  reInt <- pars[["reInt"]]
  
  lambda_re <- (log(reInt) + mu_bg * reDur +  mu_me * meDur
                - lambda_bg * meDur) / reDur
  
  bmSigma2 <- pars[["bmSigma2"]]
  
  stQ01 <- pars[["stQ01"]]
  stQ10 <- stQSum - stQ01
  
  stQ <- matrix(c(0, stQ01, stQ10, 0), 2, 2)
  
  lambda_null <- stepfun(c(reStart, reStart + reDur),
                         c(lambda_bg, lambda_re, lambda_bg))
  
  mu_null <- stepfun(c(meStart, meStart + meDur),
                     c(mu_bg, mu_me, mu_bg))
  
  expNt <- Vectorize(function(t) {
    exp(integrate(function(x) lambda_null(x) - mu_null(x), 0, t)$value)
  })

  expTotalNt <- function(t) {
    integrate(function(x) lambda_null(x) * expNt(x), 0, t, 
              stop.on.error = FALSE)$value
  }
  
  tMax <- uniroot(function(t) expTotalNt(t) - nExp, 
                  c(meStart + meDur + reDur, 
                    meStart + meDur + reDur + 10))$root
  
  EX <- expected.trait(stQ01, stQ10)
  
  lambdaModDisc <- pars[["lambdaModDisc"]]
  
  lambda_bg_0 <- lambda_bg / (1 + lambdaModDisc * EX)
  
  lambdaModCont <- pars[["lambdaModCont"]]
  
  lambda <- function(t, traits) {
    reStart <- meStart + meDur
    reEnd <- reStart + reDur
    ifelse((t < reStart) || (t > reEnd),                    
           # BG
           lambda_bg_0 + lambda_bg_0 * lambdaModDisc * traits[2],
           # RE
           lambda_re - lambdaModCont * lambda_re * 
             (abs(bmX0 - traits[1]) - sqrt(2 * bmSigma2 * t / pi)))
  }
  
  muModDisc <- pars[["muModDisc"]]
  
  mu_me_0 <- mu_me / (1 + muModDisc * EX)
  
  muModCont <- 0.05 
  
  mu <- function(t, traits) {
    ifelse((t < meStart) || (t > meStart + meDur),
           # BG
           mu_bg + muModCont * mu_bg * 
             (abs(traits[1] - bmX0) - sqrt(2 * bmSigma2 * t / pi)),
           # ME
           mu_me_0 + mu_me_0 * muModDisc * traits[2])
  }
  
  # make trait pars list
  traitPars <- list(BM = list(sigma2 = bmSigma2, X0 = bmX0, bounds = list(bmBounds)),
                    ST = list(states = list(c(0, 1)), X0 = stX0, Q = list(stQ)))
  
  ## create directories
  
  # base directory for simulations with parameter combination comb
  dir <- paste0(simDir, "comb_", comb, "/")
  smart.dir.create(dir)
  
  # null directory
  nullDir <- paste0(dir, "null/")
  smart.dir.create(nullDir)
    
  # fossil data frames directory (null)
  nullFossilsDir <- paste0(nullDir, "fossils/")
  smart.dir.create(nullFossilsDir)
  
  # trees directory (null)
  nullTreesDir <- paste0(nullDir, "trees/")
  smart.dir.create(nullTreesDir)
  
  # create trait sims directory
  traitsDir <- paste0(dir, "traits/")
  smart.dir.create(traitsDir)
  
  # traits lists directory (traits)
  traitListsDir <- paste0(traitsDir, "trait_lists/")
  smart.dir.create(traitListsDir)
  
  # fossil data frames directory (traits)
  traitsFossilsDir <- paste0(traitsDir, "fossils/")
  smart.dir.create(traitsFossilsDir)
  
  # trees directory (traits)
  traitsTreeDir <- paste0(traitsDir, "trees/")
  smart.dir.create(traitsTreeDir)
  
  ## run simulations
  # run null simulations
  simRepsNull <- lapply(1:nReps, function(x) 
    simulate_rep(tMax, lambda_null, mu_null, nFinal, rho, bins,
                 bmSigma2, bmX0, stQ, stX0, null = TRUE))
  
  # get simulations
  simListNull <- lapply(1:nReps, function(x) simRepsNull[[x]]$SIM)
  
  # save simulation RData
  save(simListNull, file = paste0(nullDir, "sim_list.RData"))
  
  # get fossil records
  fossilsListNull <- lapply(1:nReps, function(x) simRepsNull[[x]]$SAMP)
  
  # save fossil records as tsv
  lapply(1:nReps, function(x)
    write_tsv(fossilsListNull[[x]], paste0(nullFossilsDir, "fossils_", 
                                           x, ".tsv")))
  
  # get trees
  treeListNull <-  lapply(1:nReps, function(x) simRepsNull[[x]]$TREE)
  
  # save trees as .nex
  lapply(1:nReps, function(x)
    write.nexus(treeListNull[[x]], file = paste0(nullTreesDir, "tree_",
                                                 x, ".nex")))
  
  # and same for saTrees
  saTreeListNull <-  lapply(1:nReps, function(x) simRepsNull[[x]]$SATREE)
  
  lapply(1:nReps, function(x)
    write.nexus(saTreeListNull[[x]], file = paste0(nullTreesDir, "saTree_",
                                                   x, ".nex")))
  
  # aaand fbd trees
  fbdTreeListNull <-  lapply(1:nReps, function(x) simRepsNull[[x]]$FBDTREE)
  
  lapply(1:nReps, function(x)
    write.nexus(fbdTreeListNull[[x]], file = paste0(nullTreesDir, "fbdTree_",
                                                    x, ".nex")))
  
  # run trait simulations
  simTraitsReps <- lapply(1:nReps, function(x) 
    simulate_rep(tMax, lambda_null, mu_null, nFinal, rho, bins,
                 bmSigma2, bmX0, stQ, stX0, null = FALSE))
  
  # extract simulations and trait functions
  simList <- lapply(1:nReps, function(x) simTraitsReps[[x]]$SIM)
  bmTraitsFunc <- lapply(1:nReps, function(x) simTraitsReps[[x]]$TRAITFUNCC)
  stTraitsFunc <- lapply(1:nReps, function(x) simTraitsREPS[[x]]$TRAITFUNCD)
    
  # save simulation RData
  save(simList, file = paste0(traitsDir, "sim_list.RData"))
  
  # and trait RData
  save(bmTraitsFunc, file = paste0(traitsDir, "bm_traits.RData"))
  save(stTraitsFunc, file = paste0(traitsDir, "st_traits.RData"))
  
  # get trait lists
  bmTraitList <- lapply(1:nReps, function(x) simTraitReps[[x]]$TRAITSC)
  stTraitList <- lapply(1:nReps, function(x) simTraitReps[[x]]$TRAITSD)
  
  # save them as .nex
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(bmTraitList[[x]], 
                     file = paste0(traitListsDir, "bm_traits_", x, ".nex"))))
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(stTraitList[[x]], 
                     file = paste0(traitListsDir, "st_traits_", x, ".nex"))))
  
  # get fossil records
  fossilsList <- lapply(1:nReps, function(x) simTraitsREPS[[x]]$SAMPLE)

  # save fossil records as tsv
  invisible(lapply(1:nReps, function(x)
    write_tsv(fossilsList[[x]], paste0(traitsFossilsDir, "fossils_", 
                                           x, ".tsv"))))
  
  # get trees
  treeList <-  lapply(1:nReps, function(x) simTraitsReps[[x]]$TREE)
  
  # save trees as .nex
  lapply(1:nReps, function(x)
    write.nexus(treeList[[x]], file = paste0(traitsTreeDir, "tree_",
                                             x, ".nex")))
  
  # and same for saTrees
  saTreeListNull <-  lapply(1:nReps, function(x) simTraitsReps[[x]]$SATREE)
  
  lapply(1:nReps, function(x)
    write.nexus(saTreeListNull[[x]], file = paste0(traitsTreesDir, "saTree_",
                                                   x, ".nex")))
  
  # aaand fbd trees
  fbdTreeList <-  lapply(1:nReps, function(x) simTraitReps[[x]]$FBDTREE)
  
  lapply(1:nReps, function(x)
    write.nexus(fbdTreeList[[x]], file = paste0(traitsTreesDir, "fbdTree_",
                                                x, ".nex")))
}

# run simulations
invisible(lapply(1:nrow(key),
                 function(x)
                   simulate(nReps, x, key)))